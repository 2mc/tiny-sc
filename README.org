* Done
- UGen shortcuts: Env, out
- ProcessRegistry:  Register Nodes, Routines, EventStreamPlayers and stop them from a GUI
- Emacs: Eval / select code blocks between comments
- Emacs/org-mode:
  - Eval code in sections, replace/stop processes belonging to a section
  - Wrap code in Routine to permit using =wait=, and play loops.
  - Load all sections whose AUTOLOAD property is non-nil.
- MixBus alpha
  - also shortcut: synth => \mixBusName

* Underway
** MixBus class

Subclass of Bus.

MixBus(name, numChans, out); // create new instance if needed, and make it current.

Alternative for above:
\name.mixBus(numChans, out);

Also creates its own Group.
When created:

- registers itself in MixBus.all class variable under its given name (symbol), for access.
- sets the following current environemnt variables:
  - ~out :: index of the bus. Synths can write to this bus.
  - ~target :: its group
- Creates synth called =gain= positioned after =~target=, providing:
  - global level control (control name: =gain=)
  - adsr envelope for fadeout with method =release(releaseTime)=
- The =gain= synth directs its output to another channel, per default channel 0.
- Different types of =gain= synths can be used, to provide effects and multichannel output
- Other synths can be added before =gain= to provide additional effects.
- Syn(...) reads ~out an ~target from the environment, and therefore by default uses the installed MixBus, if present.
- Define keyboard shortcuts in SC for altering the level control of the current mixbus (the one belonging to the current environment).
- Create GUI for MixBus.  The gui can show all mixbusses stored in MixBus.all.
- The =gain= synth can be released to shut output of a mixbus.  A new gain synth can be created at any moment to restart output, or even to crossfade a different type of output.
- To remove a mixBus entirely call mixBus.remove.  This releases the gain synth, removes the group when the gain synth is freed, removes the mixBus from the =all= variable, and frees the bus.

* Next plans:

** More convenient ways to map/set Synth parameters

- method bmap :: map to bus created implicitly for a control-rate synth.
- method rmap :: map to routine created implicitly for a stream.
- method gmap :: map to gui instance created from specs.

*** Synth:bmap : map parameter to a bus to which a synth outputs.

bmap(parameter/controller, controlSynth)

- =parameter/controller= :: A symbol or an association parameter->controller. =parameter= is the name of the parameter of the synth to be mapped. =controller= is the symbol under which the synth is stored. If no controller name is given, then the controller name defaults to the parameter name.

Access bus as value in a global dictionary of Synth-bus or symbol-bus associations.
Create new bus if not already present, and set output of controlSynth to bus index.
Map parameter to index of bus.

bus should/may be freed and removed from global dictionary when all of its synth inputs are freed.

*** Node:rmap : set parameter of node to values obtained by a routine

rmap(parameter/controller, valueStream, timeStream)

- =parameter/controller= :: A symbol or an association parameter->controller. =parameter= is the name of the parameter of the synth to be set by the routine. =controller= is the symbol under which the routine is stored. If no controller name is given, then the controller name defaults to the parameter name.
- =valueStream= :: Any object.  Values are obtained from the stream by sending it the message next.  Patterns are converted to streams with asStream before being used.
- =timeStream= :: Any object that returns a stream of positive integers (duration values) when sent the message next. (Similar to valueStream).

**** first prototype - polling streams with a routine and timing
The routine is created rougly like this:

{
	var val, dur;
	while { (val = valStream.next).notNil and: { (dur = durStream.next).notNil } }
	{
		thisThread.changed(\value, val, dur);
		dur.wait;
	};
	this.changed(\p_end);
}

The controlled Synth may choose to =free= or =release= itself when receiving =\p_end= at the end of the routine process.

**** extension: encapsulate routine in Source object

Encapsulate the routine in another object that sends the notifications, so that one may substitute a new routine in that object and still keep the connections to all listeners controlled by the object.

This object/class could be called Source (Streamer, Poller, Brodcaster?).  It can hold any object that wants to broadcast a stream of values, such as a poller of audio or control stream values, a tcp poller, an osc or midi event listener, a gui widget event listerer etc.  Finally, the listening objects receiving notifications from the Source instance can use adapters to react differently to the data received.  We thus have:

**** MapFunc: Encapsulate mapping action and message to listener

Encapsulate the spec in the mapping function, thereby saving the trouble to store specs in an extra variable.  Also exchange mapping or other type of response functions at any moment, without having to store these actions anywhere.  Use =Object:removeNotifier(notifier, message)= to remove the previous instance of the notification and replace it with the new one.

Variables of MapFunc:

- listener :: object that receives the message and converted value from the update.
- notifier :: object that sends the values
- message :: message that the values are send with.  Default is \value.

The three items above can be useful to the MapFunc as sources of further information or targets of further actions when performing its action.  Therefore the action is passed the MapFunc instance along with the value, so that it may retrieve further info from the listener or notifier, or perform other actions on them or remove itself etc.

- action :: function that maps or otherwise acts on the value received from the update.  Note: A spec does not need to be stored separately, because it can be made available to the function through a closure created by another function that creates the action function.  The action returns an array whose first element is the message to be performed by the listener and the rest of the elements are arguments to that message.

***** Connecting an object to an updater (Source)

Message for connecting an object to an updater (Source) - yet see next subsection below!

: specF(action)

Action can be constructed by messages to Arrays, Functions, or other types of objects.
For example =\freq.asSpec.setter(\freq)= would return a function that returns an array:
=[\set, \freq, mappedValue]=.  Or this could be further abridged to: =\freq.mapper= where the name of the parameter to be set defaults to the receiver.

Here is maybe a better version:

***** Shortcuts for connecting an object to a Source:

Use standard prefix v (variable) or s (source) for the method names.  For example:

=vmap= is for variable map, where map is from the map operation in Lisp, which operates on each value of a collection (in this case, the stream of incoming values).

=vmap= is sent to a Symbol.  It creates a MapFunc instance, named after the symbol, without an action.  The action can then be set by sending the instance messages. Such messages are:

- =map= :: Create a function that sends the listener the message set thus: =listener.set(parameter, mappedValue)=.  The parameter can be provided as argument.  The spec for mapping the input value is also created from data passed as argument.
- =unmap= :: Like map, except that the spec is used to unmap instead of to map.
- =bimap= :: Like above, except it uses a custom class =BiMap= (see Lilt2 library) to map from aaaaany custom range to any other custom range.
- =args= :: evaluate each of the args passed to this function each time with the value received, collect the resulting array, and send it as message to the listener thus: =listener.perform(*args);

Here some earlier drafts with details - not entirely consistent with the above.

Examples:

=set= creates a function that sends the set message with the value mapped through a spec produced from a specPrototype, guesses the parameter name from the prototype, or gets it from paramName, and optionally inserts restargs between the parameter name and the mapped value.

: listener.vmap(source).2qset(specPrototype, (optional:) paramName ... restargs)

#+BEGIN_EXAMPLE
// listener.vmap(source) does the following:
var mapFunc;
mapFunc = MapFunc(listener, source);
listener.addNotifier(source, \value, mapFunc);
^mapFunc;
#+END_EXAMPLE

The returned mapFunc is used to construct the action by sending it

Most general case: collect the result of evaluating each of the args with the value as argument, and send it to the listener with listener.perform(*args). Thus, even the message sent can vary according to the input.  We may use a special message =null= defined for Object, to send any object messages that should be ignored (null method).

: vmap(source).send(... args);

For example:

aSynth.vset(aStreamSource).spec(\freq);
aSynth.vset(aStreamSource).spec([10, 100],

Seletive action constructors could be defined:

vselect(source).select()
vreject(source).reject()


** Org-table as score?

* Done:

- Adsr, Sine, Perc :: Env shortcuts
- out :: Out.ar/kr shortcut.
- Notification :: Filter "changed" notifications, add and remove notifiers.
- ProcessRegistry :: Keep track of running Nodes, Routines, Patterns.
- ProcessRegistryGui :: Display list of running processes, delete key stops selected process.
- sclang-snippets :: Shortcuts to navigate and run code blocks separated by =//:=.
- org-sc :: Evaluate SC code in org-mode sections and babel blocks.
- Store processes under a key representing the snippet or org-mode section from which they were started.  Thus make it possible to stop or replace the processes that belong to the current snippet or org-mode section.  For sections: Use the org-id ID as id and the name of the section for display.  For snippets: Generate name if not present in =//:= header, add number if not unique.

** More features
- org-sc :: Load org-mode sections marked with AUTOLOAD property.
- sclang-snippets :: select current snippet region.
* Implementation notes

** Stopping processes started from code contained in an org-mode section

Pass the id of the current snippet/section as environment variable by enclosing the code to be evaluated with =sc-lang-eval-string= in a function evaluated within a new environment.

#+BEGIN_SRC elisp
  (sclang-eval-string
     (concat
      "(source_id: '"
      (org-id-get-create)
      "', eval_id: UniqueID.next) use: {\n"
      string
      "\n}"
  ))
#+END_SRC

Storing the ID-process correspondences in SC: Store each process in an instance of NamedProcess, with its org-section (source) ID and eval ID (the number of times that this snippet is currently running).

The eval id is stored as property in the org-section.

** Process trees?

To kill all child-processes of a Routine one may add thisThread as notifier to a child process (Node or Routine or EventStreamPlayer) and notify the children when the thread stops.  Similarly for EventStreamPlayer.  Registering processes under a snippet/org-section id is a simpler alternative. However process-tree based stopping is a different thing, because one may want to kill a parent-process through the gui, independent fom the snippet grouping which may contain also other processes.

* Older Plans:

- Add to sclang-snippets:
  - Each snippet eval output is stored in list of objects, in emacs buffer,
    for access, eg. to free or pause a synth, routine, group, pattern player etc.
  - If return value is synth: store synth
  - If return value is routine: create own group for putting synths in,
    so that synths are also freed when routine is stopped?
    Possible?  Only via currentEnvironment.  Use variant of Synth.new
    to access currentEnvironment's target?
    This could be method synth of string or symbol, called in similar manner as Synth.new:
    Instead of Synth("test"), write synth("test").
  - Similar to routine, also for Pbinds.
    Check if Pbind accesses currentEnvironment to get \target value.
    If so, then implementing private group per snippet should be easy.


IZ Tue, 25 Feb 2014 16:20:26ff
