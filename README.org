* Done
- UGen shortcuts: Env, out
- ProcessRegistry:  Register Nodes, Routines, EventStreamPlayers and stop them from a GUI
- Emacs: Eval / select code blocks between comments
- Emacs/org-mode:
  - Eval code in sections, replace/stop processes belonging to a section
  - Wrap code in Routine to permit using =wait=, and play loops.
  - Load all sections whose AUTOLOAD property is non-nil.
- MixBus alpha
  - also shortcut: synth => \mixBusName

* Underway
** MixBus class

Subclass of Bus.

MixBus(name, numChans, out); // create new instance if needed, and make it current.

Alternative for above:
\name.mixBus(numChans, out);

Also creates its own Group.
When created:

- registers itself in MixBus.all class variable under its given name (symbol), for access.
- sets the following current environemnt variables:
  - ~out :: index of the bus. Synths can write to this bus.
  - ~target :: its group
- Creates synth called =gain= positioned after =~target=, providing:
  - global level control (control name: =gain=)
  - adsr envelope for fadeout with method =release(releaseTime)=
- The =gain= synth directs its output to another channel, per default channel 0.
- Different types of =gain= synths can be used, to provide effects and multichannel output
- Other synths can be added before =gain= to provide additional effects.
- Syn(...) reads ~out an ~target from the environment, and therefore by default uses the installed MixBus, if present.
- Define keyboard shortcuts in SC for altering the level control of the current mixbus (the one belonging to the current environment).
- Create GUI for MixBus.  The gui can show all mixbusses stored in MixBus.all.
- The =gain= synth can be released to shut output of a mixbus.  A new gain synth can be created at any moment to restart output, or even to crossfade a different type of output.
- To remove a mixBus entirely call mixBus.remove.  This releases the gain synth, removes the group when the gain synth is freed, removes the mixBus from the =all= variable, and frees the bus.

* Next plans:

** More convenient ways to map/set Synth parameters

- method bmap :: map to bus created implicitly for a control-rate synth.
- method rmap :: map to routine created implicitly for a stream.
- method gmap :: map to gui instance created from specs.

*** Synth:bmap : map parameter to a bus to which a synth outputs.

bmap(parameter/controller, controlSynth)

=parameter/controller= :: A symbol or an association parameter->controller. =parameter= is the name of the parameter of the synth to be mapped. =controller= is the symbol under which the synth is stored. If no controller name is given, then the controller name defaults to the parameter name.

Access bus as value in a global dictionary of Synth-bus or symbol-bus associations.
Create new bus if not already present, and set output of controlSynth to bus index.
Map parameter to index of bus.

bus should/may be freed and removed from global dictionary when all of its synth inputs are freed.

*** Node:rmap : set parameter of node to values obtained by a routine

rmap(parameter/controller, valueStream, timeStream)

- =parameter/controller= :: A symbol or an association parameter->controller. =parameter= is the name of the parameter of the synth to be set by the routine. =controller= is the symbol under which the routine is stored. If no controller name is given, then the controller name defaults to the parameter name.
- =valueStream= :: Any object.  Values are obtained from the stream by sending it the message next.  Patterns are converted to streams with asStream before being used.
- =timeStream= :: Any object that returns a stream of positive integers (duration values) when sent the message next. (Similar to valueStream).

*** first prototype - polling streams with a routine and timing
The routine is created rougly like this:

{
	var val, dur;
	while { (val = valStream.next).notNil and: { (dur = durStream.next).notNil } }
	{
		thisThread.changed(\value, val, dur);
		dur.wait;
	};
	this.changed(\p_end);
}

The controlled Synth may choose to =free= or =release= itself when receiving =\p_end= at the end of the routine process.

*** extension: encapsulate routine in Source object

Encapsulate the routine in another object that sends the notifications, so that one may substitute a new routine in that object and still keep the connections to all listeners controlled by the object.

This object/class could be called Source (Streamer, Poller, Brodcaster?).  It can hold any object that wants to broadcast a stream of values, such as a poller of audio or control stream values, a tcp poller, an osc or midi event listener, a gui widget event listerer etc.  Finally, the listening objects receiving notifications from the Source instance can use adapters to react differently to the data received.  We thus have:

** Org-table as score?

* Done:

- Adsr, Sine, Perc :: Env shortcuts
- out :: Out.ar/kr shortcut.
- Notification :: Filter "changed" notifications, add and remove notifiers.
- ProcessRegistry :: Keep track of running Nodes, Routines, Patterns.
- ProcessRegistryGui :: Display list of running processes, delete key stops selected process.
- sclang-snippets :: Shortcuts to navigate and run code blocks separated by =//:=.
- org-sc :: Evaluate SC code in org-mode sections and babel blocks.
- Store processes under a key representing the snippet or org-mode section from which they were started.  Thus make it possible to stop or replace the processes that belong to the current snippet or org-mode section.  For sections: Use the org-id ID as id and the name of the section for display.  For snippets: Generate name if not present in =//:= header, add number if not unique.

** More features
- org-sc :: Load org-mode sections marked with AUTOLOAD property.
- sclang-snippets :: select current snippet region.
* Implementation notes

** Stopping processes started from code contained in an org-mode section

Pass the id of the current snippet/section as environment variable by enclosing the code to be evaluated with =sc-lang-eval-string= in a function evaluated within a new environment.

#+BEGIN_SRC elisp
  (sclang-eval-string
     (concat
      "(source_id: '"
      (org-id-get-create)
      "', eval_id: UniqueID.next) use: {\n"
      string
      "\n}"
  ))
#+END_SRC

Storing the ID-process correspondences in SC: Store each process in an instance of NamedProcess, with its org-section (source) ID and eval ID (the number of times that this snippet is currently running).

The eval id is stored as property in the org-section.

** Process trees?

To kill all child-processes of a Routine one may add thisThread as notifier to a child process (Node or Routine or EventStreamPlayer) and notify the children when the thread stops.  Similarly for EventStreamPlayer.  Registering processes under a snippet/org-section id is a simpler alternative. However process-tree based stopping is a different thing, because one may want to kill a parent-process through the gui, independent fom the snippet grouping which may contain also other processes.

* Older Plans:

- Add to sclang-snippets:
  - Each snippet eval output is stored in list of objects, in emacs buffer,
    for access, eg. to free or pause a synth, routine, group, pattern player etc.
  - If return value is synth: store synth
  - If return value is routine: create own group for putting synths in,
    so that synths are also freed when routine is stopped?
    Possible?  Only via currentEnvironment.  Use variant of Synth.new
    to access currentEnvironment's target?
    This could be method synth of string or symbol, called in similar manner as Synth.new:
    Instead of Synth("test"), write synth("test").
  - Similar to routine, also for Pbinds.
    Check if Pbind accesses currentEnvironment to get \target value.
    If so, then implementing private group per snippet should be easy.


IZ Tue, 25 Feb 2014 16:20:26ff
